#+TITLE: Personal Emacs Config
#+STARTUP: overview
#+OPTIONS: toc:2 num:nil H:8
#+OPTIONS: tags:nil
#+OPTIONS: html-postamble:nil


* About
:PROPERTIES:
:CUSTOM_ID: About
:END:

This is my attempt at a self-documented Emacs configuration. It is aimed towards
programming (C, Python, Bash and more) and document writing with Org mode. I
have stolen a lot of this stuff from some very kind people, feel free to do the
same here :)

The usual disclaimer applies: note that this is a constant work-in-progress
setup, you should expect it to be quite hacky and not thoroughly tested. Always
refer to the documentation when in doubt. Now please, have at it!

Here are some setups that helped me build this one, you should check them out!

- [[https://github.com/howardabrams/dot-files/tree/master][Howard Abrams]]
- [[https://github.com/larstvei/dot-emacs][Lars Tveito]]
- [[https://github.com/protesilaos/dotfiles/tree/master/emacs/.emacs.d][Protesilaos]]
- [[https://github.com/hrs/dotfiles/blob/main/emacs/.config/emacs/configuration.org][Robin Schwartz]]

* Prelude
:PROPERTIES:
:CUSTOM_ID: Prelude
:END:
*** Emacs Server
:PROPERTIES:
:CUSTOM_ID: Prelude-server
:END:

Starting Emacs as a server allows to spawn instantly multiple clients sharing
the same buffers without the need to reload the configuration file every time. I
then use ~alias emc='emacsclient -c '~ in my =.bashrc= file to start a new Emacs
client in the terminal and connect to the server.

#+begin_src emacs-lisp :tangle yes
(require 'server)
(unless (server-running-p) (server-start))
#+end_src

*** User Files
:PROPERTIES:
:CUSTOM_ID: Prelude-files
:END:

Define the files and directories that will be used across the configuration.

#+begin_src emacs-lisp :tangle yes
(setq skw/d-base     user-emacs-directory
      skw/f-config   (concat skw/d-base "skywhi.org")
      skw/f-custom   (concat skw/d-base "custom.el")
      skw/d-elisp    (concat skw/d-base "my_elisp/")
      skw/d-savedir  (concat skw/d-base "saves")
      skw/f-savehist (concat skw/d-base "savehist")
      skw/d-snippets (concat skw/d-base "my_snippets/")
      )
#+end_src

Also add custom Emacs Lisp files to =load-path= while we are at it.

#+begin_src emacs-lisp :tangle yes
(when (and (boundp 'skw/d-elisp)
           (file-readable-p skw/d-elisp))
  (add-to-list 'load-path skw/d-elisp))
#+end_src

*** Customize File
:PROPERTIES:
:CUSTOM_ID: Prelude-customize
:END:

Use a separate =custom.el= file instead of cluttering our beloved =init.el= with
ad-hoc customizations.

#+begin_src emacs-lisp :tangle yes
(setq custom-file skw/f-custom)
(unless (file-exists-p custom-file)
  (write-region "" nil custom-file))
(load custom-file)
#+end_src

*** Package Initialization
:PROPERTIES:
:CUSTOM_ID: Prelude-package
:END:

I get my packages from the [[https://melpa.org/packages/][MELPA]] and [[https://orgmode.org/elpa/][ORG]] repositories. The only package which
needs to be installed "manually" is [[https://github.com/jwiegley/use-package][use-package]]. It will take care of installing
the remaining packages (with the =:ensure t= flag) for us.

#+begin_src emacs-lisp :tangle yes
(require 'package)

(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/"))
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/"))

(package-initialize)
(when (not package-archive-contents)
  (package-refresh-contents))

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package)
  (setq use-package-always-defer t))
#+end_src

Let's always compile packages thanks to =auto-compile= to make sure that Emacs
never loads outdated code. And keep warnings during intialisation to a minimum.

#+begin_src emacs-lisp :tangle yes
(use-package auto-compile
  :ensure t
  :config
  (setq load-prefer-newer t)
  (auto-compile-on-load-mode))

(setq byte-compile-warnings '(cl-functions)
      warning-minimum-level :emergency)
#+end_src

*** Elisp Utility Libraries

Gimme [[https://github.com/magnars/dash.el][dash]].

#+begin_src emacs-lisp :tangle yes
(use-package dash
  :ensure t)
#+end_src

* General Settings
:PROPERTIES:
:CUSTOM_ID: General
:END:
*** Start-up and Sane Defaults
:PROPERTIES:
:CUSTOM_ID: General-startup
:END:
***** Scratch buffer

Let's jump right in, shall we?

#+begin_src emacs-lisp :tangle yes
(setq inhibit-startup-screen t)
(setq initial-major-mode 'org-mode)
(setq initial-scratch-message "#+TITLE: Aloha !\n")
#+end_src

***** Default modes and hooks

These are the built-in modes and hooks that I like to have enabled by
default.

#+begin_src emacs-lisp :tangle yes
;; Default built-in modes
(setq default-major-mode 'text-mode)
(auto-compression-mode t)        ;; Handle compressed files
(file-name-shadow-mode t)        ;; Better minibuffer filenames
(save-place-mode t)              ;; Remember point location
(global-auto-revert-mode t)      ;; Automagically refresh buffers
(global-subword-mode t)          ;; Treat camelCase as 2 words
(global-font-lock-mode t)        ;; Syntax highlighting
(global-prettify-symbols-mode t) ;; Prettify things if possible
(visual-line-mode t)             ;; Better word-wrap and truncation

;; Hooks
(add-hook 'find-file-hook 'goto-address-mode)      ;; Prettify urls and emails
(add-hook 'find-file-hook 'goto-address-prog-mode) ;; Also in strings and comments
(add-hook 'text-mode-hook 'turn-on-auto-fill)      ;; Automatically wrap text
(add-hook 'before-save-hook 'whitespace-cleanup)   ;; Delete extra whitespaces
#+end_src

***** Encoding

Let's be paranoid and force some UTF-8 goodness everywhere we can.

#+begin_src emacs-lisp :tangle yes
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setq-default buffer-file-coding-system 'utf-8)
#+end_src

***** Miscellaneous options

Change various small options for convenience.

#+begin_src emacs-lisp :tangle yes
(defalias 'yes-or-no-p 'y-or-n-p) ;; Save ourselves some precious keystrokes
(setq echo-keystrokes 0.1         ;; Shorter display delay
      calendar-week-start-day 1   ;; Start week on Monday
      use-dialog-box nil          ;; Discrete!
      ring-bell-function 'ignore  ;; And quiet!
      visible-bell t)             ;; Blink instead of ring when bell is on
#+end_src

*** UI Tweaks
:PROPERTIES:
:CUSTOM_ID: General-ui
:END:
***** Appearance

Get rid of the toolbars and time display but keep the line/column numbers
in the status line.

#+begin_src emacs-lisp :tangle yes
(menu-bar-mode -1)
(blink-cursor-mode t)
(line-number-mode t)
(column-number-mode t)
(global-hl-line-mode 0)

(setq display-time-mode nil
      display-time-default-load-average nil)

;; In case I happen to run a GUI Emacs #YouNeverKnow
(when window-system
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (global-hl-line-mode))
#+end_src

***** Frames

Set the frame title and always start fullscreen frames.

#+begin_src emacs-lisp :tangle yes
(setq frame-title-format '(buffer-file-name "%f" ("%b")))
(modify-all-frames-parameters '((fullscreen . maximized)))
#+end_src

***** Fonts

I demand pretty text!

#+begin_src emacs-lisp :tangle yes
(font-lock-ensure)
(setq font-lock-maximum-decoration t)
#+end_src

Toogle *font-lock-mode* on / off.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-c M-p") 'font-lock-mode)
#+end_src

***** Windows

Move between windows with =C-x <key>=.

#+begin_src emacs-lisp :tangle yes

(use-package buffer-move
  :ensure t
  :bind (("C-x <up>" .    'buf-move-up)
         ("C-x <down>" .  'buf-move-down)
         ("C-x <left>" .  'buf-move-left)
         ("C-x <right>" . 'buf-move-right)))
#+end_src

The built-in =winner-mode= allows to undo and redo window layouts with =C-c
<left/right>=.

#+begin_src emacs-lisp :tangle yes
(when (fboundp 'winner-mode)
  (winner-mode 1))
#+end_src

Delete all windows except the current one with =C-z=.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-z") 'delete-other-windows)
#+end_src

***** Scrolling

Smoother scrolling options and keybindings to scroll unfocused windows.

#+begin_src emacs-lisp :tangle yes
(setq redisplay-dont-pause t
      scroll-margin 5
      scroll-step 2
      scroll-preserve-screen-position 1)

(defun skw/scroll-other-window-up ()
  (interactive)
  (if (boundp 'scroll-step)
      (scroll-other-window scroll-step)
    (scroll-other-window 1)))

(defun skw/scroll-other-window-down ()
  (interactive)
  (if (boundp 'scroll-step)
      (scroll-other-window-down scroll-step)
    (scroll-other-window-down 1)))

(global-set-key (kbd "C-x v <up>")   'skw/scroll-other-window-down)
(global-set-key (kbd "C-x v <down>") 'skw/scroll-other-window-up)
(global-set-key (kbd "C-v") 'scroll-down)
(global-set-key (kbd "M-n") 'scroll-up)
#+end_src

***** Mouse

#+begin_src emacs-lisp :tangle yes
(require 'mouse)
(xterm-mouse-mode t)
(defun track-mouse (e))
(setq mouse-sel-mode t)
(global-set-key (kbd "<mouse-4>")    'scroll-down)
(global-set-key (kbd "<wheel-up>")   'scroll-down)
(global-set-key (kbd "<mouse-5>")    'scroll-up)
(global-set-key (kbd "<wheel-down>") 'scroll-up)
(setq mouse-wheel-scroll-amount '(1 ((shift) . 1) ((control) . nil)))
(setq mouse-wheel-progressive-speed t)
#+end_src

***** Themes

A safer =load-theme= function that disables previously loaded themes before
executing a new one.

#+begin_src emacs-lisp :tangle yes
(defadvice load-theme
    (before disable-before-load (theme &optional no-confirm no-enable)
            activate)
  (mapc 'disable-theme custom-enabled-themes))
#+end_src

Some themes from [[https://protesilaos.com/emacs/ef-themes][ef-themes]] by [[https://protesilaos.com/][Protesilaos Stavrou]] that I like with custom
keybindings to switch between them.

#+begin_src emacs-lisp :tangle yes
(use-package ef-themes
  :ensure t
  :bind (("C-c t t" . 'skw/disable-custom-themes)
         ("C-c t d" . 'skw/ef-load-dark)
         ("C-c t b" . 'skw/ef-load-bio))
  :config
  (defun skw/disable-custom-themes ()
    (interactive)
    (dolist (i custom-enabled-themes)
      (disable-theme i)))

  (defun skw/ef-load-bio ()
    (interactive)
    (load-theme 'ef-bio))

  (defun skw/ef-load-dark ()
    (interactive)
    (load-theme 'ef-dark)))
#+end_src

***** =Diminish=

=diminish= lets us hide unwanted modes from the mode-line.

#+begin_src emacs-lisp :tangle yes
(use-package diminish
  :ensure t)
#+end_src

***** =Smart-mode-line=

Better looking mode-line, other themes are included for testing.

#+begin_src emacs-lisp :tangle yes
(use-package smart-mode-line
  :ensure t
  :init
  (setq sml/shorten-directory t
        sml/shorten-modes t)
  :config
  (setq sml/theme 'light)
  ;; (setq sml/theme 'respectful)
  ;; (setq sml/theme 'dark)
  (sml/setup))
#+end_src

***** =Volatile-highlights=

This [[https://www.emacswiki.org/emacs/VolatileHighlights][package]] highlights recent region-related changes like /undo/ or /yank/.

#+begin_src emacs-lisp :tangle yes
(use-package volatile-highlights
  :ensure t
  :diminish volatile-highlights-mode
  :config
  (volatile-highlights-mode t))
#+end_src

***** Rebind =M-x=

I define them here but they will be overwritten by the =ivy= package
later on.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "M-x")   'execute-extended-command)
(global-set-key (kbd "C-c m") 'execute-extended-command)
#+end_src

***** =ivy= + =swiper= + =counsel= = <3

[[https://github.com/abo-abo/swiper][Ivy]] ([[https://oremacs.com/swiper/][documentation]]) is an interactive interface for completion in Emacs. It
comes along with =counsel= for Emacs command completion and =swiper= as an
alternative to =isearch=. Together, they provide a more comprehensive,
graphically intuitive and effective to the vanilla Emacs experience.

The snippets below are mostly taking from [[https://protesilaos.com/][Protesilaos Stavrou]]'s setup
(especially this [[https://github.com/protesilaos/dotfiles/blob/aa8a5d96b013462cfa622e396e65abb66725318a/emacs/.emacs.d/emacs-init.org][commit]], as his configuration has changed since then).
Protesilaos provides awesome Emacs-related content and heavily contributes to
the Emacs ecosystem , make sure you check it out!

https://protesilaos.com/codelog/2019-12-15-emacs-ivy-fzf-rg/

#+begin_src emacs-lisp :tangle yes
(use-package ivy
  :ensure t
  :diminish
  :bind (("C-s s" . swiper)

         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-f" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-n" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         ("C-p" . ivy-previous-line)

         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)

         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))

  :init
  (global-unset-key (kbd "C-s"))
  (ivy-mode 1)

  :config
  (defun skw/ivy-open-current-typed-path ()
    (interactive)
    (when ivy--directory
      (let* ((dir ivy--directory)
             (text-typed ivy-text)
             (path (concat dir text-typed)))
        (delete-minibuffer-contents)
        (ivy--done path))))

  (setq ivy-use-virtual-buffers t
        ivy-count-format "(%d/%d) "
        ivy-wrap t)

  (set-face-attribute 'highlight nil :background "color-40")
  (set-face-attribute 'ivy-current-match nil :extend t :background "color-40" :foreground "black")
  (set-face-attribute 'ivy-cursor nil :background "cyan" :foreground "white")
  (set-face-attribute 'ivy-minibuffer-match-face-1 nil :background "brightmagenta" :foreground "white")
  (set-face-attribute 'ivy-minibuffer-match-face-2 nil :background "brightmagenta" :foreground "white" :weight 'bold))

(use-package ivy-rich
  :ensure t
  :config
  (setcdr (assq t ivy-format-functions-alist) #'ivy-format-function-line)
  (ivy-rich-mode 1))


(use-package prescient
  :ensure t
  :custom
  (prescient-history-length 100)
  (prescient-save-file "~/.emacs.d/prescient-items")
  (prescient-filter-method '(fuzzy initialism regexp))
  :config
  (prescient-persist-mode 1))

(use-package ivy-prescient
  :ensure t
  :after (prescient ivy)
  :custom
  (ivy-prescient-sort-commands
   '(:not swiper ivy-switch-buffer counsel-switch-buffer))
  (ivy-prescient-retain-classic-highlighting t)
  (ivy-prescient-enable-filtering t)
  (ivy-prescient-enable-sorting t)
  :config
  (defun skw/ivy-prescient-filters (str)
    "Specify an exception for `prescient-filter-method'.
  This new rule can be used to tailor the results of individual
  Ivy-powered commands, using `ivy-prescient-re-builder'."
    (let ((prescient-filter-method '(literal regexp)))
      (ivy-prescient-re-builder str)))

  (setq ivy-re-builders-alist
        '((counsel-rg . skw/ivy-prescient-filters)
          (counsel-grep . skw/ivy-prescient-filters)
          (counsel-yank-pop . skw/ivy-prescient-filters)
          (swiper . skw/ivy-prescient-filters)
          (swiper-isearch . skw/ivy-prescient-filters)
          (swiper-all . skw/ivy-prescient-filters)
          (t . ivy-prescient-re-builder)))

  (ivy-prescient-mode 1))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package counsel
  :ensure t
  :bind (("M-x" . counsel-M-x)
         ("C-c m" . counsel-M-x)
         ("C-x b" . counsel-ibuffer)
         ("C-x C-f" . counsel-find-file)
         ("C-x M-f" . find-file-other-window)
         ("C-M-l" . counsel-imenu)
         ("C-h f" . counsel-describe-function)
         ("C-h v" . counsel-describe-variable)

         ("C-s r" . counsel-rg)
         ("C-s z" . skw/counsel-fzf-rg-files)

         ("M-y" . counsel-yank-pop)

         :map minibuffer-local-map
         ("C-r" . 'counsel-minibuffer-history)

         :map counsel-find-file-map
         ("C-d" . 'skw/ivy-open-current-typed-path))

  :config

  (defun skw/counsel-fzf-rg-files (&optional input dir)
    "Run `fzf' in tandem with `ripgrep' to find files in the
  present directory.  Both of those programs are external to
  Emacs."
    (interactive)
    (let ((process-environment
           (cons (concat "FZF_DEFAULT_COMMAND=rg -Sn --color never --files --no-follow --hidden")
                 process-environment)))
      (counsel-fzf input dir)))

  (defun skw/counsel-rg-dir (arg)
    "Specify root directory for `counsel-rg'."
    (let ((current-prefix-arg '(4)))
      (counsel-rg ivy-text nil "")))

  (defun skw/counsel-fzf-dir (arg)
    (skw/counsel-fzf-rg-files ivy-text
                              (read-directory-name
                               (concat (car (split-string counsel-fzf-cmd))
                                       " in directory: "))))


  (setq ivy-initial-inputs-alist nil

        ;; counsel yank options
        counsel-yank-pop-preselect-last t
        counsel-yank-pop-separator "\n—————————\n"

        ;; commands used by counsel
        counsel-rg-base-command
        "rg -SHn --no-heading --color never --no-follow --hidden %s"
        counsel-find-file-occur-cmd
        "ls -a | grep -i -E '%s' | tr '\\n' '\\0' | xargs -0 ls -d --group-directories-first")

  (let ((done (where-is-internal #'ivy-done     ivy-minibuffer-map t))
        (alt  (where-is-internal #'ivy-alt-done ivy-minibuffer-map t)))
    (define-key counsel-find-file-map done #'ivy-alt-done)
    (define-key counsel-find-file-map alt  #'ivy-done))

  (ivy-add-actions
   'counsel-fzf
   '(("r" skw/counsel-fzf-dir "change root directory")
     ("g" skw/counsel-rg-dir "search with rg"))))

(ivy-add-actions
 'counsel-rg
 '(("r" skw/counsel-rg-dir "change root directory")
   ("z" skw/counsel-fzf-dir "find files with fzf in root directory")))

(use-package flx
  :after ivy
  :defer t
  :init
  (setq ivy-flx-limit 10000))
#+end_src

***** Exiting Emacs


=C-x C-x= will shutdown emacs-server if the current frame is the last
instance. =C-x M-x= will leave the server running in the background instead.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-x 5 0") 'delete-frame)
(global-set-key (kbd "C-x M-x") 'delete-frame)
(global-set-key (kbd "C-x C-c")
                (lambda (arg)
                  (interactive "P")
                  (if arg
                      (call-interactively 'save-buffers-kill-emacs)
                    (save-buffers-kill-terminal))))
#+end_src

*** Files
:PROPERTIES:
:CUSTOM_ID: General-files
:END:
***** Get current directory

#+begin_src emacs-lisp :tangle yes
(defun skw/get-file-directory ()
  "Return the full path to the current open file, without the file name."
  (if (null load-file-name)
      (expand-file-name default-directory)
    (file-name-directory load-file-name)))
#+end_src

***** Open if file is readable

Simply open a file if it exists already, otherwise don't create a new one.

#+begin_src emacs-lisp :tangle yes
(defun skw/open-file-readable (fname)
  "Open a file, does not create a new file if it does not exist"
  (interactive)
  (if (file-readable-p fname)
      (progn
        (find-file fname)
        (message (format "Opened %s" fname)))
    (message (format "File %s does not exist" fname))))
#+end_src

***** Quickly access files

Here I add some files to quickly open them with =C-c f <key>=. Like this
configuration file.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-c f f") (lambda () (interactive)
                                  (skw/open-file-readable skw/f-config)))
#+end_src

***** Backups

Store backup files in a =~/.emacs.d/saves= directory and mini-buffer history
into a =~/.emacs.d/savehist= file.

#+begin_src emacs-lisp :tangle yes
(setq backup-directory-alist `(("." . skw/d-savedir))
      backup-by-copying t
      auto-save-default t
      auto-save-timeout 20
      auto-save-interval 200
      version-control t
      kept-new-versions 6
      kept-old-versions 2
      delete-old-versions t)

(setq savehist-additional-variables
      '(search-ring regexp-search-ring)
      savehist-file skw/f-savehist)
(savehist-mode t)
#+end_src

*** Buffers
:PROPERTIES:
:CUSTOM_ID: General-buffers
:END:
***** Manually revert buffer

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "<f5>") 'revert-buffer)
#+end_src

***** Minibuffer

#+begin_src emacs-lisp :tangle yes
(setq history-length 250
      history-delete-duplicates t
      enable-recursive-minibuffers t)

(add-hook 'minibuffer-exit-hook
          '(lambda ()
             (let ((buffer "*Completions*"))
               (and (get-buffer buffer) (kill-buffer buffer)))))
#+end_src

***** =miniedit=

With =miniedit= it is possible to edit large minibuffer commands
by opening a dedicated buffer with =C-M-e=.

#+begin_src emacs-lisp :tangle yes
(use-package miniedit
  :ensure t
  :commands minibuffer-edit
  :init
  (miniedit-install))
#+end_src

***** =ibuffer=

For a better buffer list/menu.

#+begin_src emacs-lisp :tangle yes
(defalias 'list-buffers 'ibuffer)
(add-hook 'ibuffer-mode-hook
          (lambda ()
            (ibuffer-auto-mode 1)
            (ibuffer-switch-to-saved-filter-groups "default")))

(setq ibuffer-show-empty-filter-groups nil
      ibuffer-expert t)

;; Kept for self reference. This layout is overwritten by ibuffer-projectile
(setq ibuffer-saved-filter-groups
      (quote (("default"
               ("c"
                (mode . c-mode))

               ("php"
                (mode . php-mode))

               ("python"
                (mode . python-mode))

               ("haskell"
                (mode . haskell-mode))

               ("org" (or
                       (mode . org-mode)
                       (name . "^.*org$")
                       (name . "^\\*Calendar\\*$")
                       (name . "^\\*Org Agenda\\*$")))

               ("rg"
                (mode . ripgrep-mode))

               ("sh"
                (mode . sh-mode))

               ("emacs" (or
                         (name . "^\\*scratch\\*$")
                         (name . "^\\*Backtrace\\*$")
                         (name . "^\\*Help\\*$")
                         (name . "^\\*Messages\\*$")
                         (name . "^\\*Compile-Log\\*$")))))))

(use-package ibuffer-projectile
  :ensure t
  :config
  (setq ibuffer-formats
        '((mark modified read-only " "
                (name 18 18 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " "
                project-relative-file)))
  (add-hook 'ibuffer-hook
            (lambda ()
              (ibuffer-projectile-set-filter-groups)
              (unless (eq ibuffer-sorting-mode 'alphabetic)
                (ibuffer-do-sort-by-alphabetic)))))
#+end_src

***** =uniquify=

Makes buffer names unique when needed to avoid possible confusions.

#+begin_src emacs-lisp :tangle yes
(require 'uniquify)
(setq  uniquify-buffer-name-style 'post-forward
       uniquify-separator ":"
       uniquify-after-kill-buffer-p t
       uniquify-ignore-buffers-re "^\\*")
#+end_src

***** =projectile=

#+begin_src emacs-lisp :tangle yes
(use-package projectile
  :diminish projectile-mode
  :ensure t
  :bind-keymap
  ("C-c p" . projectile-command-map)
  ("M-p" . projectile-command-map)
  :config (projectile-mode)
  ;; ignoring specific buffers by name
  (setq projectile-globally-ignored-buffers
        '("*scratch*"
          "*lsp-log*")

        ;; ignoring buffers by their major mode
        projectile-globally-ignored-modes
        '("erc-mode"
          "help-mode"
          "completion-list-mode"
          "Buffer-menu-mode"
          "gnus-.*-mode"
          "occur-mode")

        projectile-sort-order 'recently-active
        projectile-enable-caching t
        projectile-dynamic-mode-line t
        projectile-auto-cleanup-known-projects t))
#+end_src

*** Editing
:PROPERTIES:
:CUSTOM_ID: General-editing
:END:
***** Autofill, indent, tabs, whitespaces & friends

Some "textual" cosmetics.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "<f7>")   'toggle-truncate-lines)
(global-set-key (kbd "S-<f7>") 'auto-fill-mode)
(global-set-key (kbd "C-c i")  'skw/cleanup-buffer-or-region)
(global-set-key (kbd "C-c q")  'fill-paragraph)
(global-set-key (kbd "M-q")    'fill-paragraph)

(setq-default truncate-lines t
              truncate-partial-width-windows nil
              indent-tabs-mode nil
              tab-width 4
              fill-column 80
              sentence-end-double-space nil
              show-trailing-whitespace nil ;; edit???
              require-final-newline nil)

;; Indent
(defun skw/indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max))
  (message "Indented buffer"))

(defun skw/indent-region ()
  (interactive)
  (indent-region (region-beginning) (region-end))
  (message "Indented region"))

;; Replace tabs by spaces
(defun skw/untabify-buffer ()
  (interactive)
  (untabify (point-min) (point-max))
  (message "Untabified buffer"))

(defun skw/untabify-region ()
  (interactive)
  (untabify (region-beginning) (region-end))
  (message "Untabified region"))

;; Cleanup = untabify + indent + whitespaces
(defun skw/cleanup-buffer ()
  (interactive)
  (skw/untabify-buffer)
  (skw/indent-buffer)
  (delete-trailing-whitespace)
  (message "Cleaned-up buffer"))

(defun skw/cleanup-region ()
  (interactive)
  (skw/untabify-region)
  (skw/indent-region)
  (delete-trailing-whitespace)
  (message "Cleaned-up region"))

;; All in one
(defun skw/cleanup-buffer-or-region ()
  (interactive)
  (save-excursion
    (if (region-active-p)
        (skw/cleanup-region)
      (skw/cleanup-buffer))))
#+end_src

***** Case change

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "M-l") 'downcase-word)
(global-set-key (kbd "M-o") 'capitalize-word)
(global-set-key (kbd "M-i") 'upcase-word)
#+end_src

***** Copy/paste

#+begin_src emacs-lisp :tangle yes
(setq kill-ring-max 100
      save-interprogram-paste-before-kill 1
      yank-pop-change-selection t)
#+end_src

With this hack, if the region is empty then the current line is copied /
killed instead. Makes you spare a few keystrokes.

#+begin_src emacs-lisp :tangle yes
(defadvice kill-ring-save (before slick-copy activate compile)
  "When called interactively with no active region, copy a single line instead."
  (interactive
   (if mark-active
       (progn
         (message "Copied region")
         (list (region-beginning) (region-end)))

     (progn
       (message "Copied line")
       (list (line-beginning-position)
             (line-beginning-position 2))))))

(defadvice kill-region (before slick-cut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active
       (progn
         (message "Killed region")
         (list (region-beginning) (region-end)))

     (progn
       (message "Killed line")
       (list (line-beginning-position)
             (line-beginning-position 2))))))
#+end_src

Kill text from the current position to the beginning of line.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "M-k") 'skw/kill-to-bol)

(defun skw/kill-to-bol ()
  "Kill text from point to beginning of line."
  (interactive)
  (kill-region (point) (line-beginning-position)))
#+end_src

***** Escape / unescape quotes

Escape or unescape quotes in the selection. If no region is marked, applies to
the current line instead. Taken from [[ https://ergoemacs.org/emacs/elisp_escape_quotes.html][ergoemacs]].

#+begin_src emacs-lisp :tangle yes
(defun skw/escape-quotes (@begin @end)
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (list (line-beginning-position) (line-end-position))))
  (save-excursion
    (save-restriction
      (narrow-to-region @begin @end)
      (goto-char (point-min))
      (while (search-forward "\"" nil t)
        (replace-match "\\\"" "FIXEDCASE" "LITERAL"))))
  (message "Escaped quotes"))

(defun skw/unescape-quotes (@begin @end)
  (interactive
   (if (use-region-p)
       (list (region-beginning) (region-end))
     (list (line-beginning-position) (line-end-position))))
  (save-excursion
    (save-restriction
      (narrow-to-region @begin @end)
      (goto-char (point-min))
      (while (search-forward "\\\"" nil t)
        (replace-match "\"" "FIXEDCASE" "LITERAL"))))
  (message "Unescaped quotes"))
#+end_src

***** Goto-line

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-x C-l") 'goto-line)
#+end_src

***** Case manipulation

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-x M-l") 'downcase-region)
#+end_src

***** Macros

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "<f3>") 'kmacro-start-macro-or-insert-counter)
(global-set-key (kbd "<f4>") 'kmacro-end-or-call-macro)
#+end_src

***** Mark & region

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-x p")   'pop-to-mark-command)
(global-set-key (kbd "C-x n n") 'narrow-to-region)
(global-set-key (kbd "C-x n w") 'widen)

(delete-selection-mode t)
(transient-mark-mode t)
(put 'narrow-to-region 'disabled nil)
(setq select-active-regions t
      set-mark-command-repeat-pop t)
#+end_src

***** Parenthesis

Quick and dirty style change to highlight and underline matching
parentheses.

#+begin_src emacs-lisp :tangle yes
(require 'paren)
(show-paren-mode 1)
(set-face-background 'show-paren-match (face-background 'default))
(set-face-foreground 'show-paren-match "#def")
(set-face-attribute 'show-paren-match nil :underline t)
#+end_src

***** =company=

I am using =company-mode= for auto-completion, switching it
on/off with =<F11>= (current buffer) and =S-<F11>= (globally).
Navigate between completions with =C-n= and =C-p= or with the
up/down arrows.

#+begin_src emacs-lisp :tangle yes
(use-package company
  :ensure t
  :diminish company-mode "Com"
  :bind
  (("<f10>"   . company-mode)
   ("S-<f10>" . global-company-mode)
   ("M-/" . company-complete)
   ("<tab>" . company-indent-or-complete-common)

   :map company-active-map
   ("C-n" . company-select-next)
   ("C-p" . company-select-previous)
   ("C-d" . company-show-doc-buffer)
   ("M-." . company-show-location))

  :init
  (setq company-tooltip-limit 20
        company-show-numbers t
        company-dabbrev-downcase nil
        company-minimum-prefix-length 3
        company-idle-delay 0.5
        company-echo-delay 0)

  (add-hook 'c-mode-common-hook 'company-mode)
  (add-hook 'sgml-mode-hook 'company-mode)
  (add-hook 'emacs-lisp-mode-hook 'company-mode)
  (add-hook 'text-mode-hook 'company-mode)
  (add-hook 'lisp-mode-hook 'company-mode)
  (add-hook 'sh-mode-hook 'company-mode)
  (add-hook 'org-mode-hook 'company-mode)

  :config
  (add-to-list 'company-backends 'company-math-symbols-unicode)
  (global-company-mode))
#+end_src

Using [[https://github.com/company-mode/company-statistics][company-statistics]] to rearrange suggestions made by =company= by frequency
of usage:

#+begin_src emacs-lisp :tangle yes
(use-package company-statistics
  :ensure t
  :after company
  :config
  (company-statistics-mode))
#+end_src

***** =ripgrep=

#+begin_src emacs-lisp :tangle yes
(use-package ripgrep
  :ensure t
  :bind
  (("C-c d d" . ripgrep-regexp))
  :config
  (set-face-attribute 'ripgrep-match-face nil
                      :foreground "dodger blue"
                      :background "none")

  (set-face-attribute 'ripgrep-hit-face nil
                      :foreground "red"))
#+end_src

***** =flyspell=

I use =flyspell= along with the =hunspell= backend to spellcheck a region/buffer
(=C-c s=). This requires the [[https://archlinux.org/packages/extra/any/words/][words]] and [[https://archlinux.org/packages/extra/x86_64/hunspell/][hunspell]] packages on ArchLinux.

#+begin_src emacs-lisp :tangle yes
;; US, GB, FR and DE dictionaries
(defun skw/flyspell-dict-american ()
  (interactive)
  (ispell-change-dictionary "en_US")
  (setq ispell-alternate-dictionary "/usr/share/dict/american-english"))

(defun skw/flyspell-dict-english ()
  (interactive)
  (ispell-change-dictionary "en_GB")
  (setq ispell-alternate-dictionary "/usr/share/dict/british-english"))

(defun skw/flyspell-dict-french ()
  (interactive)
  (ispell-change-dictionary "fr_FR")
  (setq ispell-alternate-dictionary "/usr/share/dict/french"))

(defun skw/flyspell-dict-german ()
  (interactive)
  (ispell-change-dictionary "de_DE")
  (setq ispell-alternate-dictionary "/usr/share/dict/ngerman"))

(defun skw/flyspell-buffer-or-region ()
  "If region is active, calls flyspell-region.
     Otherwise flyspell-buffer is called. "
  (interactive)
  (save-excursion
    (if (region-active-p)
        (progn
          (flyspell-region (region-beginning) (region-end))
          (message "Spellchecked region"))
      (progn
        (flyspell-buffer)
        (message "Spellchecked buffer")))))

(use-package flyspell
  :ensure t
  :diminish flyspell-mode "spell"
  :bind (("S-<f6>" . flyspell-mode)
         ("C-c s e" . skw/flyspell-dict-american)
         ("C-c s g" . skw/flyspell-dict-english)
         ("C-c s f" . skw/flyspell-dict-french)
         ("C-c s d" . skw/flyspell-dict-german)
         ("C-c s s" . skw/flyspell-buffer-or-region)
         ("M-$"     . ispell-word)
         ("M-*"     . flyspell-auto-correct-word)
         ("M-ù"     . flyspell-goto-next-error))
  :init
  (setq ispell-program-name (executable-find "hunspell")
        ispell-dictionary "en_US")
  :config
  (flyspell-mode 1))

(defun restart-flyspell-mode ()
  (when flyspell-mode
    (flyspell-mode-off)
    (flyspell-mode-on)))
(add-hook 'ispell-change-dictionary-hook 'restart-flyspell-mode)
#+end_src

***** =ediff=

#+begin_src emacs-lisp :tangle yes
;; Fix new window opening / splitting
(setq ediff-window-setup-function 'ediff-setup-windows-plain
      ediff-split-window-function 'split-window-horizontally)
(add-hook 'ediff-after-quit-hook-internal 'winner-mode)

;; Show whitespaces properly
(add-hook 'diff-mode-hook
          (lambda ()
            (setq-local whitespace-style
                        '(face
                          tabs
                          tab-mark
                          spaces
                          space-mark
                          trailing
                          indentation::space
                          indentation::tab
                          newline
                          newline-mark))))
#+end_src

***** =expand-region=

Very useful utility to quickly select growing blocks of text.

#+begin_src emacs-lisp :tangle yes
(use-package expand-region
  :ensure t
  :bind ("M-," . er/expand-region))
#+end_src

***** =undo-tree=

Visualize undo history with =C-x u= with timestamps and diffs. Press =q=
to quit.

#+begin_src emacs-lisp :tangle yes
(use-package undo-tree
  :ensure t
  :diminish undo-tree-mode
  :init
  (setq undo-tree-visualizer-timestamps t
        undo-tree-visualizer-diff t
        undo-tree-auto-save-history nil)
  :config
  (global-undo-tree-mode))
#+end_src

***** =xclip=

The classic copy/paste tricks from the OS clipboard (requires *xclip* from
Xorg).

#+begin_src emacs-lisp :tangle yes
(use-package xclip
  :ensure t
  :init
  (setq select-active-regions nil
        select-enable-primary t
        select-enable-clipboard t
        mouse-drag-copy-region t)
  :config
  (xclip-mode 1))
#+end_src

*** Misc Utilities
:PROPERTIES:
:CUSTOM_ID: General-misc
:END:
***** Add to auto-mode-alist

#+begin_src emacs-lisp :tangle yes
(defun skw/add-auto-mode (mode &rest patterns)
  "Use `mode` with given filename `patterns`"
  (dolist (pattern patterns)
    (add-to-list 'auto-mode-alist (cons pattern mode))))
#+end_src

***** List installed packages

#+begin_src emacs-lisp :tangle yes
(defun skw/list-installed-packages ()
  "Return a list of all installed packages with their versions"
  (interactive)
  (mapcar
   (lambda (pkg)
     `(,pkg ,(package-desc-version
              (cadr (assq pkg package-alist)))))
   package-activated-list))
#+end_src

***** =howdoi=

Looking-up Stack Overflow answers in an Emacs buffer.

#+begin_src emacs-lisp :tangle yes
(use-package howdoi
  :ensure t
  :defer t)
#+end_src

***** =which-key=

Great helper to find and remember keybindings.

#+begin_src emacs-lisp :tangle yes
(use-package which-key
  :ensure t
  :diminish which-key-mode
  :init
  (setq which-key-sort-order 'which-key-key-order-alpha)
  :config
  (which-key-mode))
#+end_src

***** =discover-my-major=

Get help for major modes.

#+begin_src emacs-lisp :tangle yes
(use-package discover-my-major
  :ensure t
  :bind (("C-h C-m" . discover-my-major)
         ("C-h M-m" . discover-my-mode)))
#+end_src

***** =sensitive-minor-mode=

Used to prevent backups of sensitive files, like .gpg (from
=.emacs.d/my_elisp/=) by *Emacs only*, you still have to check git
and such of course.

#+begin_src emacs-lisp :tangle yes
(use-package sensitive-minor-mode
  :diminish sensitive-minor-mode "Sens"
  :init
  (setq auto-mode-alist
        (append '(("\\.gpg$" . sensitive-minor-mode)
                  ("\\.secret$" . sensitive-minor-mode)
                  ("\\.secrets$" . sensitive-minor-mode))
                auto-mode-alist)))
#+end_src

***** Tmux compliance

See [[https://wiki.archlinux.org/index.php/Emacs#Shift_.2B_Arrow_keys_not_working_in_emacs_within_tmux][here]].

#+begin_src emacs-lisp :tangle yes
(defadvice terminal-init-screen
    ;; The advice is named `terminal-init-screen', and is run before `tmux' runs.
    (before tmux activate)
  "Apply xterm keymap, allowing use of keys passed through tmux."
  (if (getenv "TMUX")
      (let ((map (copy-keymap xterm-function-map)))
        (set-keymap-parent map (keymap-parent input-decode-map))
        (set-keymap-parent input-decode-map map))))
#+end_src

* Programming
:PROPERTIES:
:CUSTOM_ID: Programming
:END:
*** General Stuff
:PROPERTIES:
:CUSTOM_ID: Programming-general
:END:
***** compilation buffer

#+begin_src emacs-lisp :tangle yes
(setq compilation-scroll-output  t
      compilation-ask-about-save nil
      compilation-scroll-output  'next-error
      compilation-skip-threshold 2)

(require 'ansi-color)
(defun skw/colorize-buffer ()
  "Add colors to the compilation buffer output."
  (toggle-read-only)
  (ansi-color-apply-on-region (point-min) (point-max))
  (toggle-read-only))

(add-hook 'compilation-filter-hook 'skw/colorize-buffer)
#+end_src

***** (un)comment region or line

#+begin_src emacs-lisp :tangle yes
(defun skw/comment-or-uncomment-region-or-line ()
  " Comment or uncomment the region or the current line if no region is active."
  (interactive)
  (let (beg end)
    (if (region-active-p)
        (setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)))

(global-set-key (kbd "M-;") 'skw/comment-or-uncomment-region-or-line)
#+end_src

***** =flycheck=

Toggle =flycheck-mode= with =<f6>= and =C-<f6>=.

#+begin_src emacs-lisp :tangle yes
(use-package flycheck
  :ensure t
  :diminish flycheck-mode "check"
  :bind (("<f6>"   . flycheck-mode)
         ("C-<f6>" . global-flycheck-mode))
  :hook ((c-mode
          c++-mode
          emacs-lisp-mode
          lisp-interaction-mode
          python-mode)
         . flycheck-mode)
  :config
  (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
  (flycheck-mode 1))
#+end_src

***** =rainbows=

I need colors in my life!

#+begin_src emacs-lisp :tangle yes
(use-package rainbow-delimiters
  :ensure t
  :hook ((prog-mode) . rainbow-delimiters-mode))

(use-package rainbow-identifiers
  :ensure t
  :hook ((prog-mode) . rainbow-identifiers-mode))

;; Display the color identifier's color as background
(use-package rainbow-mode
  :ensure t
  :diminish rainbow-mode
  :hook (css-mode
         emacs-lisp-mode
         html-mode
         js-mode
         org-mode))
#+end_src

***** =yasnippet=

Note that personal snippets (=skw/d-snippets=) must be added before the
defaults (=yas-installed-snippets-dir=) to effectively override them.

#+begin_src emacs-lisp :tangle yes
(use-package yasnippet
  :ensure t
  :diminish yas-minor-mode "ys"
  :bind (("<tab>" . #'yas-maybe-expand)
         ("C-c y v" . #'yas-visit-snippet-file)
         ("C-c y n" . #'yas-new-snippet)
         ("C-c y y" . #'yas-insert-snippet))
  :init
  (setq yas-snippet-dirs '(skw/d-snippets ))
  :config
  (yas-global-mode 1))
#+end_src

*** Language Specific
:PROPERTIES:
:CUSTOM_ID: Programming-specific
:END:
***** c/c++

Some basic K&R style settings.

#+begin_src emacs-lisp :tangle yes
(require 'cc-mode)
(setq c-default-style "k&r"
      c-basic-indent 4
      c-basic-offset 4)
#+end_src

Use =ggtags= to index symbols from a codebase and navigate to them.

#+begin_src emacs-lisp :tangle yes
(use-package ggtags
  :ensure t
  :diminish ggtags-mode ""
  :config
  (add-hook 'c-mode-hook 'ggtags-mode))
#+end_src

***** conf-mode

#+begin_src emacs-lisp :tangle yes
(skw/add-auto-mode 'conf-mode
                   "\\.conf$"
                   "\\.config$"
                   "\\.configuration$"
                   "\\.gitconfig$"
                   "\\.gitignore$")
#+end_src

***** haskell

The following cabal packages need to be installed and the  =~/cabal/bin=
directory needs to be added to our =$PATH=.

#+begin_src shell
$ cabal update
$ cabal install happy hasktags hindent hlint
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package haskell-mode
  :ensure t
  :defer t
  :bind (:map haskell-mode-map
              ("C-c C-l" . haskell-process-load-or-reload)
              ("C-c C-z" . haskell-interactive-switch)
              ("C-c C-c" . haskell-process-cabal-switch)
              :map haskell-cabal-mode-map
              ("C-c C-z" . haskell-interactive-switch))

  :init
  ;; setup cabal PATH
  (let ((my-cabal-path (expand-file-name "~/.cabal/bin")))
    (setenv "PATH" (concat my-cabal-path path-separator (getenv "PATH")))
    (add-to-list 'exec-path my-cabal-path))

  ;; haskell preferences
  (setq haskell-ask-also-kill-buffers nil
        haskell-tags-on-save t
        haskell-stylish-on-save t
        haskell-process-type 'cabal-repl
        haskell-process-auto-import-loaded-modules t
        haskell-process-log t)

  :config
  (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
  (add-hook 'haskell-mode-hook (lambda () (interactive-haskell-mode t))))
#+end_src

***** lisp

Display information about a variable or function at point with =eldoc=.

#+begin_src emacs-lisp :tangle yes
(add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
(add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
#+end_src

Summon an =ielm= repl in a separate window with =C-c l i=.

#+begin_src emacs-lisp :tangle yes
(global-set-key (kbd "C-c l i") 'skw/ielm)

(defun skw/ielm ()
  (interactive)
  (split-window-below -12)
  (other-window 1)
  (ielm)
  (set-window-dedicated-p (selected-window) t))
#+end_src

Eval the s-expr at point and print the result with =C-x j=.

#+begin_src emacs-lisp :tangle yes
(define-key lisp-interaction-mode-map (kbd "C-x j") 'eval-print-last-sexp)
#+end_src

***** markdown

#+begin_src emacs-lisp :tangle yes
(use-package markdown-mode
  :ensure t
  :config
  (skw/add-auto-mode 'markdown-mode
                     "\\.md$"
                     "\\.mdown$")
  (add-hook 'markdown-mode-hook #'auto-fill-mode)

  ;; highlight code blocks without changing fonts
  (setq markdown-fontify-code-blocks-natively t)
  (set-face-attribute 'markdown-code-face nil
                      :inherit nil))
#+end_src

***** python

#+begin_src emacs-lisp :tangle yes
(setq python-indent-offset 4)
(skw/add-auto-mode 'python-mode
                   "\\.sage$")

(use-package py-autopep8
  :ensure t)

#+end_src

***** web
******* =emmet=

#+begin_src emacs-lisp :tangle yes
(use-package emmet-mode
  :ensure t
  :diminish emmet-mode "em"
  :hook (css-mode sgml-mode web-mode))
#+end_src

******* =htmlize=

Colorize html tags.

#+begin_src emacs-lisp :tangle yes
(use-package htmlize :ensure t)
#+end_src

******* =js-mode=

#+begin_src emacs-lisp :tangle yes
(defun skw/js-options ()
  "My conf for js-mode-hook."
  (setq js-indent-level 2))

(add-hook 'js-mode-hook 'skw/js-options)
#+end_src

******* =web-mode=

#+begin_src emacs-lisp :tangle yes
(use-package web-mode
  :ensure t
  :defer t
  :init
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (setq web-mode-enable-auto-closing t
        web-mode-enable-auto-quoting t))
#+end_src

***** yaml

#+begin_src emacs-lisp :tangle yes
(use-package yaml-mode
  :ensure t
  :defer t)
#+end_src

* Org-mode
:PROPERTIES:
:CUSTOM_ID: Org
:END:

I use [[https://orgmode.org/][org-mode]] for a lot of things. I use it for my overall text editing, for
literate programming (this config file is just an Org file), for /Getting Things
Done (tm)/, for tracking my personal life, and more.

My GTD configuration is detailed [[https://www.skywhi.net/posts/gtd-with-org.html][on my blog]]. In this file, I configure some sain
opinionated default values. Some of these might be overwritten by other config
files later on.

*** File extensions
:PROPERTIES:
:CUSTOM_ID: Org-files
:END:

File extensions for which org-mode should be the default major mode.

#+begin_src emacs-lisp :tangle yes
(skw/add-auto-mode 'org-mode
                   "\\.org$"
                   "\\.org_archive$"
                   "\\.note$"
                   "\\.txt$")
#+end_src

*** Contrib Repository
:PROPERTIES:
:CUSTOM_ID: Org-contrib
:END:

Packages from [[https://orgmode.org/worg/org-contrib/][org-contrib]].

#+begin_src emacs-lisp :tangle yes
(use-package org-contrib
  :ensure t)
#+end_src

*** Outline
:PROPERTIES:
:CUSTOM_ID: Org-outline
:END:

Org buffers start with folded and truncated content. I like to use an odd number
of stars for the headers and dim the leading ones.

#+begin_src emacs-lisp :tangle yes
(setq org-startup-folded t
      org-startup-truncated t
      org-odd-levels-only t
      org-hide-leading-stars t)
#+end_src

Indent paragraphes according to outline structure.

#+begin_src emacs-lisp :tangle yes
(org-indent-mode)
(setq org-startup-indented t)
#+end_src

When adding a heading or item, make sure the cursor goes to the end of the line first.

#+begin_src emacs-lisp :tangle yes
(setq org-blank-before-new-entry '((heading . nil) (plain-list-item . nil))
      org-M-RET-may-split-line nil)
#+end_src

*** Links
:PROPERTIES:
:CUSTOM_ID: Org-links
:END:

#+begin_src emacs-lisp :tangle yes
(define-key global-map (kbd "C-c M-l") 'org-store-link)
(define-key global-map (kbd "C-c C-l") 'org-insert-link-global)
(define-key org-mode-map (kbd "C-c M-o") 'org-toggle-link-display)
#+end_src

*** Refile
:PROPERTIES:
:CUSTOM_ID: Org-refile
:END:

#+begin_src emacs-lisp :tangle yes
(setq org-refile-use-outline-path 'file ;; Include filename in path
      org-outline-path-complete-in-steps nil ;; Play nice with ido
      org-refile-allow-creating-parent-nodes 'confirm ;; Create structure if needed
      org-refile-use-cache nil) ;; No need to cache anything
#+end_src

*** Exporting
:PROPERTIES:
:CUSTOM_ID: Org-exporting
:END:

Include the main exporters and set the right encoding.

#+begin_src emacs-lisp :tangle yes
(require 'ox-md)
(require 'ox-org)

(use-package ox-rss
  :ensure t)

(use-package ox-html
  :ensure nil
  :init
  (setq org-html-postamble nil
        org-export-with-section-numbers nil
        org-export-with-toc nil
        org-export-coding-system 'utf-8
        org-export-with-broken-links t))
#+end_src

*** Structure Templates
:PROPERTIES:
:CUSTOM_ID: Org-tempo
:END:

With [[https://orgmode.org/manual/Structure-Templates.html][org-tempo]], typing =<s <tab>= inserts a code block while =C-c k= prompts for
a template type to be inserted at point.

#+begin_src emacs-lisp :tangle yes
(use-package org-tempo
  :ensure nil
  :after org)
(define-key org-mode-map (kbd "C-c k") 'org-insert-structure-template)
#+end_src

Here my preferences when it comes to code blocks.

#+begin_src emacs-lisp :tangle yes
;; Navigate between source blocks
(define-key org-mode-map (kbd "C-c C-f") 'org-next-block)
(define-key org-mode-map (kbd "C-c C-b") 'org-previous-block)

(setq org-src-fontify-natively t ;; fontify code in code blocks
      org-src-preserve-indentation t ;; keep leading whitespaces
      org-src-window-setup 'current-window) ;; edit code block in current window
#+end_src

*** Babel
:PROPERTIES:
:CUSTOM_ID: Org-babel
:END:

Languages which can be evaluated in Org buffers.

#+begin_src emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '((awk . t)
   (C . t)
   (dot . t)
   (emacs-lisp . t)
   (gnuplot . t)
   (haskell . t)
   (js . t)
   (org . t)
   (perl . t)
   (plantuml . t)
   (python . t)
   (ruby . t)
   (shell . t)))
#+end_src

Do prompt before executing any code block.

#+begin_src emacs-lisp :tangle yes
(setq org-confirm-babel-evaluate t)
#+end_src

*** Agenda
:PROPERTIES:
:CUSTOM_ID: Org-agenda
:END:

Reset agenda files and commands, they will be added by other configuration files later
on.

#+begin_src emacs-lisp :tangle yes
(define-key global-map (kbd "C-c a") 'org-agenda)

(setq org-agenda-files '()
      org-agenda-custom-commands '())
#+end_src

Some personal display preferences.

#+begin_src emacs-lisp :tangle yes
(setq org-agenda-compact-blocks nil
      org-agenda-dim-blocked-tasks nil
      org-agenda-time-leading-zero t
      org-agenda-use-time-grid nil
      org-agenda-skip-scheduled-if-done t ;; !!
      org-agenda-scheduled-leaders '("" "Sched.%2dx: ")
      org-agenda-tags-column 'auto) ;; align tags right
#+end_src

*** Capture
:PROPERTIES:
:CUSTOM_ID: Org-capture
:END:

[[https://howardism.org/Technical/Emacs/capturing-intro.html][Here]] is an introduction to [[https://orgmode.org/manual/Capture.html][org-capture]]. Hitting =C-c c= from anywhere in Emacs
will prompt for a capture template.

#+begin_src emacs-lisp :tangle yes
(define-key global-map (kbd "C-c c") 'org-capture)

(setq org-capture-templates '()) ;; reset templates
(add-hook 'org-capture-before-finalize-hook 'org-align-all-tags) ;; align tags
#+end_src

*** TODOs
:PROPERTIES:
:CUSTOM_ID: Org-todos
:END:

Here are some convenience options related to state changes:

#+begin_src emacs-lisp :tangle yes
;; This enables fast selection for TODO keywords
;; Hitting "C-c C-t d" will select "DONE" for example
(setq org-use-fast-todo-selection t)

;; Enable logging of the creation of a new TODO item
(setq org-treat-insert-todo-heading-as-state-change t)

;; Log all state changes into the "LOGBOOK" drawer
(setq org-log-into-drawer "LOGBOOK")

;; When no modifier, always log the DONE timestamp
(setq org-log-done 'time)
#+end_src

*** Tags
:PROPERTIES:
:CUSTOM_ID: Org-tags
:END:

#+begin_src emacs-lisp :tangle yes
(setq org-tags-column -79) ;; Align tags to the right
#+end_src

*** Effort
:PROPERTIES:
:CUSTOM_ID: Org-effort
:END:

Making the property uppercase like the others.

#+begin_src emacs-lisp :tangle yes
(setq org-effort-property "EFFORT")
#+end_src

*** Priorities
:PROPERTIES:
:CUSTOM_ID: Org-priorities
:END:

Move priorities with =S-Up= and =S-Down=.

#+begin_src emacs-lisp :tangle yes
(setq org-enable-priority-commands t)
#+end_src

*** Archiving

See [[file:my_elisp/org-archive-subtree-hierarchical.el][org-archive-subtree-hierarchical.el]] on how to preserve the subtree's
structure while archiving.

#+begin_src emacs-lisp :tangle yes
(require 'org-archive-subtree-hierarchical)
(setq org-archive-default-command 'org-archive-subtree-hierarchical)
#+end_src

*** Misc Options
:PROPERTIES:
:CUSTOM_ID: Org-misc
:END:

#+begin_src emacs-lisp :tangle yes
(setq org-fold-catch-invisible-edits 'show-and-error) ;; do not edit invisible regions

;; Still allow S-<arrow> to switch between windows
(add-hook 'org-shiftup-final-hook    'windmove-up)
(add-hook 'org-shiftdown-final-hook  'windmove-down)
(add-hook 'org-shiftleft-final-hook  'windmove-left)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+end_src
